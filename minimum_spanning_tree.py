# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MinimumSpanningTree
                                 A QGIS plugin
 This plugin finds the Minimum Spanning Tree of an input polygon shp file using Kruskal's algorithm.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-05-24
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Abdurrahman Serhan, Berk Anbaroğlu / Hacettepe University
        email                : samiselim1212@hotmail.com, banbar@hacettepe.edu.tr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
# from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, QVariant, QFileInfo
# from PyQt5.QtGui import QIcon, QGuiApplication
# from PyQt5.QtWidgets import QAction, QFileDialog, QMessageBox
# from qgis.core import *
# from qgis._gui import QgsMapCanvas, QgsMapLayerComboBox

# import inspect
# # from qgis.core import QgsApplication, QgsSettings, QgsError, QgsProcessingAlgorithm, QgsProcessingFeatureBasedAlgorithm
# from qgis.utils import iface, OverrideCursor
# from processing.gui.AlgorithmDialog import AlgorithmDialog
# from qgis.processing import alg as algfactory

# # Initialize Qt resources from file resources.py
# from .InstantPrintTool import InstantPrintDialog, InstantPrintTool
# from .resources import *
# # Import the code for the dialog
# from .minimum_spanning_tree_dialog import MinimumSpanningTreeDialog
# import os.path

from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, QVariant, QFileInfo, QSize
from PyQt5.QtGui import QIcon, QGuiApplication, QColor
from PyQt5.QtWidgets import QAction, QFileDialog, QMessageBox
from qgis.core import *
from qgis._gui import QgsMapCanvas, QgsMapLayerComboBox

import inspect
# from qgis.core import QgsApplication, QgsSettings, QgsError, QgsProcessingAlgorithm, QgsProcessingFeatureBasedAlgorithm
from qgis.utils import iface, OverrideCursor
from processing.gui.AlgorithmDialog import AlgorithmDialog
from qgis.processing import alg as algfactory

# Initialize Qt resources from file resources.py
from .InstantPrintTool import InstantPrintDialog, InstantPrintTool
from .resources import *
# Import the code for the dialog
from .minimum_spanning_tree_dialog import MinimumSpanningTreeDialog
import os.path


# Disjoint Set Class Node and Functions (MakeSet, Union and Find)
class Node:
    def __init__(self, data):
        self.data = data

    def __str__(self):
        return self.label


def MakeSet(x):
    x.parent = x
    x.rank = 0


def Union(x, y):
    xRoot = Find(x)
    yRoot = Find(y)
    if xRoot.rank > yRoot.rank:
        yRoot.parent = xRoot
    elif xRoot.rank < yRoot.rank:
        xRoot.parent = yRoot
    elif xRoot != yRoot:  # Unless x and y are already in same set, merge them
        yRoot.parent = xRoot
        xRoot.rank = xRoot.rank + 1


def Find(x):
    if x.parent == x:
        return x
    else:
        x.parent = Find(x.parent)
        return x.parent


class MinimumSpanningTree:
    """QGIS Plugin Implementation."""

    global bool_point
    bool_point = 0
    global bool_line
    bool_line = 0
    global bool_MST
    bool_MST = 0
    global radio
    radio = 0

    def __init__(self, iface):
        # self.first_start = None
        self.layers=[]
        self.inFile = ''
        self.inFiles = ''
        self.activelayer = ""  # set my active layer to null at the
        """Constructor.
        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'mst_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # this line for add the GUI and use its tools it ex: combobox, button,... is general named as self.dlg
        # in is takr the name of class and after it we write Dialog()
        self.dlg = MinimumSpanningTreeDialog()

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Network Tookit')

        self.toolbar = self.iface.addToolBar(u'Network Tookit')
        self.toolbar.setObjectName(u'Network Tookit')

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('MinimumSpanningTree', message)

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToVectorMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/minimum_spanning_tree/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Network Tookit'),
            callback=self.run,
            parent=self.iface.mainWindow())

        self.dlg.radioButton.setChecked(True)
        # toggled信号与槽函数绑定
        self.dlg.radioButton.toggled.connect(lambda: self.btnstate(self.dlg.radioButton))
        self.dlg.radioButton_2.toggled.connect(lambda: self.btnstate(self.dlg.radioButton_2))
        self.getlayer = QgsMapLayerComboBox(self.dlg.getlayer)
        self.getlayer.activated[str].connect(self.Cal)
        # self.dlg.open_shpe_files.clicked.connect(self.openShpFile)
        self.dlg.load_layer.clicked.connect(self.loadVector)
        self.dlg.min_span.clicked.connect(self.minspan)
        self.dlg.shortest_path.clicked.connect(self.stpath)
        self.dlg.bridge.clicked.connect(self.bridge)
        self.dlg.alloc.clicked.connect(self.alloc)
        # self.dlg.save_layer.clicked.connect(self.savelayer)
        self.dlg.save_layer.clicked.connect(self.Savelayer)
        self.dlg.remove_layer.clicked.connect(self.Remove_maplayer)
        self.dlg.save_layer.setToolTip("点击保存图层")

    # / Users / guanchen / Library / Application\ Support / QGIS / QGIS3 / profiles / default / python / plugins / Minimum_Spanning_Tree_QGIS / scripts / guanjian.py
    def stpath(self):
        print("run shortest path")
        _locals = {}
        # print(os.path.join(self.plugin_dir,'scripts','restart.py'))
        path=os.path.join(self.plugin_dir,'scripts','shortpath.py')
        exec(open(path.encode('utf-8')).read(), _locals)
        for name, attr in _locals.items():
            if inspect.isclass(attr) and issubclass(attr, (
                    QgsProcessingAlgorithm, QgsProcessingFeatureBasedAlgorithm)) and attr.__name__ not in (
                    "QgsProcessingAlgorithm", "QgsProcessingFeatureBasedAlgorithm"):
                alg = attr()
                break
        alg.setProvider(QgsApplication.processingRegistry().providerById("script"))
        alg.initAlgorithm()

        # if self.first_start == True:
        #     self.first_start = False

        self.stpath = alg.createCustomParametersWidget(iface.mainWindow())
        if not self.stpath:
            self.stpath = AlgorithmDialog(alg, parent=self.dlg)

        canvas = iface.mapCanvas()
        prevMapTool = canvas.mapTool()
        # show the dialog
        self.stpath.show()
        # Run the dialog event loop
        result = self.stpath.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

    def bridge(self):
        print("run articulation")
        _locals = {}
        path=os.path.join(self.plugin_dir,'scripts','articulation.py')
        exec(open(path.encode('utf-8')).read(), _locals)
        # exec(open('C:\\Users\\wyc\\AppData\\Roaming\\QGIS\\QGIS3\\profiles\\default\\python\\plugins\\minimum_spanning_tree\\scripts\\articulation.py'.encode('utf-8')).read(), _locals)
        for name, attr in _locals.items():
            if inspect.isclass(attr) and issubclass(attr, (
                    QgsProcessingAlgorithm, QgsProcessingFeatureBasedAlgorithm)) and attr.__name__ not in (
                    "QgsProcessingAlgorithm", "QgsProcessingFeatureBasedAlgorithm"):
                alg = attr()
                break
        alg.setProvider(QgsApplication.processingRegistry().providerById("script"))
        alg.initAlgorithm()

        # if self.first_start == True:
        #     self.first_start = False

        self.articulation = alg.createCustomParametersWidget(iface.mainWindow())
        if not self.articulation:
            self.articulation = AlgorithmDialog(alg, parent=self.dlg)

        canvas = iface.mapCanvas()
        prevMapTool = canvas.mapTool()
        # show the dialog
        self.articulation.show()
        # Run the dialog event loop
        result = self.articulation.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

    def alloc(self):
        print("run alloc")
        _locals = {}
        path = os.path.join(self.plugin_dir, 'scripts', 'alloc.py')
        exec(open(path.encode('utf-8')).read(), _locals)
        for name, attr in _locals.items():
            if inspect.isclass(attr) and issubclass(attr, (
                    QgsProcessingAlgorithm, QgsProcessingFeatureBasedAlgorithm)) and attr.__name__ not in (
                    "QgsProcessingAlgorithm", "QgsProcessingFeatureBasedAlgorithm"):
                alg = attr()
                break
        alg.setProvider(QgsApplication.processingRegistry().providerById("script"))
        alg.initAlgorithm()

        # if self.first_start == True:
        #     self.first_start = False

        self.articulation = alg.createCustomParametersWidget(iface.mainWindow())
        if not self.articulation:
            self.articulation = AlgorithmDialog(alg, parent=self.dlg)

        canvas = iface.mapCanvas()
        prevMapTool = canvas.mapTool()
        # show the dialog
        self.articulation.show()
        # Run the dialog event loop
        result = self.articulation.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

    def Cal(self):
        print("layer changed")
        self.dlg.mapCanvas.setLayers([self.getlayer.currentLayer()])
        self.dlg.mapCanvas.setExtent(self.getlayer.currentLayer().extent())
        self.dlg.mapCanvas.refresh()
        #mark
        global bool_point
        global bool_line
        global bool_MST
        bool_point = 0
        bool_line = 0
        bool_MST = 0

    # this methods will open file browser and load data to QGIS
    # def openShpFile(self):  # vectors data
    #     # if self.inFile is not None and self.dlg.entryshpfile.text() == '':  # if our file dose not none
    #     self.inFile = str(QFileDialog.getOpenFileName(caption="open shapefile"
    #                                                   , filter="shapefiles (*.shp)")[0])
    #     self.inFiles = self.inFile
    #     # we add vector data to my QGIS
    #     # self.iface is to connecting our plugin to QGIS and make change on qgis gui
    #     self.iface.addVectorLayer(self.inFile, str.split(os.path.basename(self.inFile), ".")[0], "ogr")
    #     # give the name of my layer to not loop when ever i need it
    #     self.my_layer = str.split(os.path.basename(self.inFile), ".")[0]
    #     self.setUsingLayer(self.my_layer)  # set my layer name.

    #     self.setVectorsToEntry(self.inFile)  # this for show the file path in the edit line in plugin's gui
        
    # elif self.dlg.entryshpfile.text() != '':
    #     inFile = self.dlg.entryshpfile.text()
    #     self.iface.addVectorLayer(inFile, str.split(os.path.basename(inFile), ".")[0], "ogr")
    #     # give the name of my layer to not loop when ever i need it
    #     self.my_layer = str.split(os.path.basename(inFile), ".")[0]
    #     self.setUsingLayer(self.my_layer)  # set my layer name.
    #     self.setVectorsToEntry(inFile)  # this for show the file path in the edit line in plugin's gui

    # this function is for show what ever is choose by the user for shp file
    # so the user will see the file path that choose
    def setVectorsToEntry(self, text):
        self.dlg.entryshpfile.setText(text)

    # 设置图层，确保为我们所选择的那一个
    # set my layer to make change on it. to do not loop all vector data more then one time
    def setUsingLayer(self, name):
        layers = [layer for layer in QgsProject.instance().mapLayers().values()]
        for layer in layers:
            # if the name of my added layer is equal to layer name set my layer.
            if layer.type() == QgsMapLayer.VectorLayer and layer.name() == name:
                self.activelayer = layer
                break

    # this part of the code it to draw line between centers in shape file
    # 将图层中心点连接起来
    # def draw_line(self):
    #     self.dlg.processbar_label.setText("Drawing Line")
    #     self.dlg.progressBar.setValue(0)
    #     self.all_edge_list = []
    #     layer = self.activelayer
    #     epsg = layer.crs().postgisSrid()
    #     iter = layer.getFeatures()  # get all the features in my shape file
    #     # new layer name and the data type of it data and where I would save it. so I save it on y ram
    #     uri = "LineString?crs=epsg:" + str(epsg) + "&field=id:integer""&index=yes"
    #     v_layer = QgsVectorLayer(uri, "line", "memory")
    #     pr = v_layer.dataProvider()  # make change on the new layers
    #     v_layer.startEditing()
    #     # the 3. part is for data type so if i live it as empty it will return the type that given in process
    #     # 4. the field length
    #     myField = QgsField("id", QVariant.Int, '', 0, 2)  # Note here the field type!
    #     dp = v_layer.dataProvider()
    #     dp.addAttributes([myField])
    #     myField2 = QgsField("neighbors_from", QVariant.Int, '', 1, 2)  # Note here the field type!
    #     dp.addAttributes([myField2])
    #     myField3 = QgsField("neighbors_to", QVariant.Int, '', 2, 2)  # Note here the field type!
    #     dp.addAttributes([myField3])
    #     myField3 = QgsField("cost", QVariant.Int, '', 3, 2)  # Note here the field type!
    #     dp.addAttributes([myField3])
    #     v_layer.updateFields()
    #     i = 0
    #     j = 0
    #     # 判断多边形是否临街如果邻接将质心连接，如果不邻接就不连接
    #     # 此处有小问题，线都连接了两遍
    #     for feature in iter:  # loop our features
    #         # print(feature)
    #         for feature1 in layer.getFeatures():  # loop the feature with them self again
    #             if feature.id() == feature1.id():  # to not take the same polygon
    #                 continue
    #             # if the geometry of two features are intersects take the first one as start point and the second
    #             # one as end point and draw line between them
    #             elif feature1.geometry().intersects(feature.geometry()) is True:
    #                 start = QgsPoint(feature.geometry().centroid().asPoint()[0],
    #                                  feature.geometry().centroid().asPoint()[1])  # X,Y of the point of the center
    #                 end = QgsPoint(feature1.geometry().centroid().asPoint()[0],
    #                                feature1.geometry().centroid().asPoint()[1])
    #                 # add the geometry to the feature,
    #                 # create a new memory layer
    #                 # create a new feature
    #                 seg = QgsFeature()
    #                 seg.setGeometry(QgsGeometry.fromPolyline([start, end]))
    #                 # add the geometry to the layer
    #                 seg.setAttributes([i, feature1.id(), feature.id(), seg.geometry().length()])
    #                 pr.addFeatures([seg])
    #                 # update extent of the layer (not necessary)
    #                 v_layer.updateExtents()
    #                 v_layer.updateFeature(seg)
    #                 v_layer.commitChanges()
    #                 newEdge = [i, [feature1.id(), feature.id()], int(seg.geometry().length())]

    #                 self.all_edge_list.append(newEdge)
    #                 i += 1
    #         j += 1
    #         processCount = int((j / layer.featureCount()) * 100)
    #         self.dlg.progressBar.setValue(processCount)
    #     QgsProject.instance().addMapLayer(v_layer)
    #     self.dlg.progressBar.setValue(100)
    #     self.dlg.processbar_label.setText("Drawing Line Finished")
    #     QGuiApplication.processEvents()
    #     global bool_line
    #     bool_line = 1

    # # find the MST of our edges.
    # def kruskal(self):
    #     self.dlg.processbar_label.setText("Computing Kruskal")
    #     self.dlg.progressBar.setValue(0)
    #     # Initialize the list of vertices
    #     l_edges = []
    #     for polyID in range(len(self.all_points)):
    #         n1 = Node(polyID)
    #         l_edges.append(n1)

    #     edgesListSorted = sorted(self.all_edge_list, key=lambda l: l[2])
    #     self.all_edge_list = edgesListSorted
    #     del edgesListSorted

    #     # MakeSet for each of the vertex
    #     [MakeSet(node) for node in l_edges]

    #     # Resulting edge list - MST
    #     self.MST = [[]]
    #     total_cost = 0
    #     i = 0
    #     for edges in range(len(self.all_edge_list)):
    #         # Find the representative set of the edge
    #         # print(str(l_edges[self.all_edge_list[edges][1][0]]))
    #         # print(str(l_edges[self.all_edge_list[edges][1][1]]))
    #         root1 = Find(l_edges[self.all_edge_list[edges][1][0]])
    #         root2 = Find(l_edges[self.all_edge_list[edges][1][1]])
    #         # If both representative nodes are the same, then we form a cycle
    #         if (root1.data == root2.data):
    #             continue
    #         else:
    #             self.MST.append([self.all_edge_list[edges][0], self.all_edge_list[edges][1]])
    #             total_cost += self.all_edge_list[edges][2]
    #             Union(root1, root2)
    #         processCount = int((i / len(self.all_edge_list)) * 100)
    #         self.dlg.progressBar.setValue(processCount)
    #         i += 1

    #     self.MST.pop(0)
    #     print("Cost: ", total_cost)  # show total cost of our MST if needed
    #     self.dlg.progressBar.setValue(100)
    #     self.dlg.processbar_label.setText("Kruskal computed")
    #     QGuiApplication.processEvents()
    #     self.draw_MST()

    # # this part is for add the center of polygon in our shp file.
    # def add_point(self):
    #     self.dlg.processbar_label.setText("Adding Points")
    #     self.dlg.progressBar.setValue(0)
    #     self.all_points = []
    #     self.activelayer = self.getlayer.currentLayer()
    #     layer = self.activelayer
    #     epsg = layer.crs().postgisSrid()
    #     # determine the layer project and the type of data
    #     uri = "Point?crs=epsg:" + str(epsg) + "&field=id:integer""&index=yes"
    #     mem_layer = QgsVectorLayer(uri,
    #                                'point',
    #                                'memory')
    #     prov = mem_layer.dataProvider()
    #     i = 0
    #     for f in layer.getFeatures():
    #         self.all_points.append(i)
    #         feat = QgsFeature()
    #         # get the geometry and get the center of them as point (x,y)
    #         pt = f.geometry().centroid().asPoint()
    #         feat.setAttributes([i])  # we can add the features that we want to attribute table
    #         feat.setGeometry(QgsGeometry.fromPointXY(pt))  # the geometry that we will add to new row in shape file
    #         prov.addFeatures([feat])  # add one ore row to my shape file
    #         processCount = int((i / layer.featureCount()) * 100)
    #         self.dlg.progressBar.setValue(processCount)
    #         i += 1
    #     self.dlg.progressBar.setValue(100)
    #     self.dlg.processbar_label.setText("Points Added")
    #     QgsProject.instance().addMapLayer(mem_layer)  # we add the layer to my qgsi and show it
    #     QGuiApplication.processEvents()
    #     global bool_point
    #     bool_point = 1

    # # draw MST by using kruskal
    # def draw_MST(self):
    #     self.dlg.processbar_label.setText("Drawing MST")
    #     self.dlg.progressBar.setValue(0)
    #     # comment part is for add the prıject type of new added layer.
    #     epsg = self.activelayer.crs().postgisSrid()
    #     # new layer name and the data type of it data and where I would save it. so I save it on y ram
    #     uri = "LineString?crs=epsg:" + str(epsg) + "&field=id:integer""&index=yes"
    #     v_layer = QgsVectorLayer(uri, "MST", "memory")
    #     self.setUsingLayer('line')
    #     layer = self.activelayer
    #     pr = v_layer.dataProvider()  # make change on the new layers
    #     v_layer.startEditing()
    #     myField = QgsField("id", QVariant.Int, '', 0, 2)
    #     dp = v_layer.dataProvider()
    #     dp.addAttributes([myField])
    #     myField1 = QgsField("cost", QVariant.Int, '', 1, 2)
    #     dp = v_layer.dataProvider()
    #     dp.addAttributes([myField1])
    #     i = 0
    #     for edge in self.MST:
    #         for feature in layer.getFeatures():  # loop our features
    #             if feature[0] == edge[0]:  # to not take the same polygon
    #                 seg = QgsFeature()
    #                 seg.setGeometry(feature.geometry())
    #                 seg.setAttributes([feature.id(), feature.geometry().length()])
    #                 pr.addFeatures([seg])
    #                 v_layer.updateExtents()
    #                 v_layer.updateFeature(seg)
    #                 v_layer.commitChanges()
    #         processCount = int((i / len(self.MST)) * 100)
    #         self.dlg.progressBar.setValue(processCount)
    #         i += 1

    #     QgsProject.instance().addMapLayer(v_layer)
    #     self.dlg.progressBar.setValue(100)
    #     self.dlg.processbar_label.setText("Drawing MST Finished")
    #     QGuiApplication.processEvents()
    #     global bool_MST
    #     bool_MST = 1
    # this part of the code it to draw line between centers in shape file
    # 将图层中心点连接起来 邻接方式
    def draw_line_near(self):
        self.dlg.processbar_label.setText("Drawing Line")
        self.dlg.progressBar.setValue(0)
        self.all_edge_list = []
        layer = self.activelayer
        epsg = layer.crs().postgisSrid()
        iter = layer.getFeatures()  # get all the features in my shape file
        # new layer name and the data type of it data and where I would save it. so I save it on y ram
        uri = "LineString?crs=epsg:" + str(epsg) + "&field=id:integer""&index=yes"
        v_layer = QgsVectorLayer(uri, "line", "memory")
        pr = v_layer.dataProvider()  # make change on the new layers
        v_layer.startEditing()
        # the 3. part is for data type so if i live it as empty it will return the type that given in process
        # 4. the field length
        myField = QgsField("id", QVariant.Int, '', 0, 2)  # Note here the field type!
        dp = v_layer.dataProvider()
        dp.addAttributes([myField])
        myField2 = QgsField("neighbors_from", QVariant.Int, '', 1, 2)  # Note here the field type!
        dp.addAttributes([myField2])
        myField3 = QgsField("neighbors_to", QVariant.Int, '', 2, 2)  # Note here the field type!
        dp.addAttributes([myField3])
        myField3 = QgsField("cost", QVariant.Int, '', 3, 2)  # Note here the field type!
        dp.addAttributes([myField3])
        v_layer.updateFields()
        i = 0
        j = 0
        # 判断多边形是否临街如果邻接将质心连接，如果不邻接就不连接
        # 此处有小问题，线都连接了两遍
        for feature in iter:  # loop our features
            # print(feature)
            for feature1 in layer.getFeatures():  # loop the feature with them self again
                if feature.id() == feature1.id():  # to not take the same polygon
                    continue
                # if the geometry of two features are intersects take the first one as start point and the second
                # one as end point and draw line between them
                elif feature1.geometry().intersects(feature.geometry()) is True:
                    start = QgsPoint(feature.geometry().centroid().asPoint()[0],
                                     feature.geometry().centroid().asPoint()[1])  # X,Y of the point of the center
                    end = QgsPoint(feature1.geometry().centroid().asPoint()[0],
                                   feature1.geometry().centroid().asPoint()[1])
                    # add the geometry to the feature,
                    # create a new memory layer
                    # create a new feature
                    seg = QgsFeature()
                    seg.setGeometry(QgsGeometry.fromPolyline([start, end]))
                    # add the geometry to the layer
                    seg.setAttributes([i, feature1.id(), feature.id(), seg.geometry().length()])
                    pr.addFeatures([seg])
                    # update extent of the layer (not necessary)
                    v_layer.updateExtents()
                    v_layer.updateFeature(seg)
                    v_layer.commitChanges()
                    newEdge = [i, [feature1.id(), feature.id()], int(seg.geometry().length())]

                    self.all_edge_list.append(newEdge)
                    i += 1
            j += 1
            processCount = int((j / layer.featureCount()) * 100)
            self.dlg.progressBar.setValue(processCount)
        QgsProject.instance().addMapLayer(v_layer)
        self.dlg.progressBar.setValue(100)
        self.dlg.processbar_label.setText("Drawing Line Finished")
        QGuiApplication.processEvents()
        global bool_line
        bool_line = 1

    # 将图层中心点连接起来 非邻接方式
    def draw_line_not(self):
        self.dlg.processbar_label.setText("Drawing Line")
        self.dlg.progressBar.setValue(0)
        self.all_edge_list = []
        layer = self.activelayer
        epsg = layer.crs().postgisSrid()
        iter = layer.getFeatures()  # get all the features in my shape file
        # new layer name and the data type of it data and where I would save it. so I save it on y ram
        uri = "LineString?crs=epsg:" + str(epsg) + "&field=id:integer""&index=yes"
        v_layer = QgsVectorLayer(uri, "line", "memory")
        pr = v_layer.dataProvider()  # make change on the new layers
        v_layer.startEditing()
        # the 3. part is for data type so if i live it as empty it will return the type that given in process
        # 4. the field length
        myField = QgsField("id", QVariant.Int, '', 0, 2)  # Note here the field type!
        dp = v_layer.dataProvider()
        dp.addAttributes([myField])
        myField2 = QgsField("neighbors_from", QVariant.Int, '', 1, 2)  # Note here the field type!
        dp.addAttributes([myField2])
        myField3 = QgsField("neighbors_to", QVariant.Int, '', 2, 2)  # Note here the field type!
        dp.addAttributes([myField3])
        myField3 = QgsField("cost", QVariant.Int, '', 3, 2)  # Note here the field type!
        dp.addAttributes([myField3])
        v_layer.updateFields()
        i = 0
        j = 0
        # 判断多边形是否临街如果邻接将质心连接，如果不邻接就不连接
        # 此处有小问题，线都连接了两遍
        for feature in iter:  # loop our features
            # print(feature)
            for feature1 in layer.getFeatures():  # loop the feature with them self again

                start = QgsPoint(feature.geometry().centroid().asPoint()[0],
                                 feature.geometry().centroid().asPoint()[1])  # X,Y of the point of the center
                end = QgsPoint(feature1.geometry().centroid().asPoint()[0],
                               feature1.geometry().centroid().asPoint()[1])
                # add the geometry to the feature,
                # create a new memory layer
                # create a new feature
                seg = QgsFeature()
                seg.setGeometry(QgsGeometry.fromPolyline([start, end]))
                # add the geometry to the layer
                seg.setAttributes([i, feature1.id(), feature.id(), seg.geometry().length()])
                pr.addFeatures([seg])
                # update extent of the layer (not necessary)
                v_layer.updateExtents()
                v_layer.updateFeature(seg)
                v_layer.commitChanges()
                newEdge = [i, [feature1.id(), feature.id()], int(seg.geometry().length())]

                self.all_edge_list.append(newEdge)
                i += 1
            j += 1
            processCount = int((j / layer.featureCount()) * 100)
            self.dlg.progressBar.setValue(processCount)
        QgsProject.instance().addMapLayer(v_layer)
        self.dlg.progressBar.setValue(100)
        self.dlg.processbar_label.setText("Drawing Line Finished")
        QGuiApplication.processEvents()
        global bool_line
        bool_line = 1

    # find the MST of our edges.
    def kruskal_near(self):
        self.dlg.processbar_label.setText("Computing Kruskal")
        self.dlg.progressBar.setValue(0)
        # Initialize the list of vertices
        l_edges = []
        for polyID in range(len(self.all_points)):
            n1 = Node(polyID)
            l_edges.append(n1)

        edgesListSorted = sorted(self.all_edge_list, key=lambda l: l[2])
        self.all_edge_list = edgesListSorted
        del edgesListSorted

        # MakeSet for each of the vertex
        [MakeSet(node) for node in l_edges]

        # Resulting edge list - MST
        self.MST = [[]]
        total_cost = 0
        i = 0
        for edges in range(len(self.all_edge_list)):
            root1 = Find(l_edges[self.all_edge_list[edges][1][0]])
            root2 = Find(l_edges[self.all_edge_list[edges][1][1]])
            # If both representative nodes are the same, then we form a cycle
            if (root1.data == root2.data):
                continue
            else:
                self.MST.append([self.all_edge_list[edges][0], self.all_edge_list[edges][1]])
                total_cost += self.all_edge_list[edges][2]
                Union(root1, root2)
            processCount = int((i / len(self.all_edge_list)) * 100)
            self.dlg.progressBar.setValue(processCount)
            i += 1

        self.MST.pop(0)
        print("Cost: ", total_cost)  # show total cost of our MST if needed
        self.dlg.progressBar.setValue(100)
        self.dlg.processbar_label.setText("Kruskal computed")
        QGuiApplication.processEvents()
        self.draw_MST_near()

    def kruskal_not(self):
        self.dlg.processbar_label.setText("Computing Kruskal")
        self.dlg.progressBar.setValue(0)
        # Initialize the list of vertices
        l_edges = []
        for polyID in range(len(self.all_points)):
            n1 = Node(polyID)
            l_edges.append(n1)

        edgesListSorted = sorted(self.all_edge_list, key=lambda l: l[2])
        self.all_edge_list = edgesListSorted
        del edgesListSorted

        # MakeSet for each of the vertex
        [MakeSet(node) for node in l_edges]

        # Resulting edge list - MST
        self.MST = [[]]
        total_cost = 0
        i = 0
        for edges in range(len(self.all_edge_list)):
            root1 = Find(l_edges[self.all_edge_list[edges][1][0]])
            root2 = Find(l_edges[self.all_edge_list[edges][1][1]])
            # If both representative nodes are the same, then we form a cycle
            if (root1.data == root2.data):
                continue
            else:
                self.MST.append([self.all_edge_list[edges][0], self.all_edge_list[edges][1]])
                total_cost += self.all_edge_list[edges][2]
                Union(root1, root2)
            processCount = int((i / len(self.all_edge_list)) * 100)
            self.dlg.progressBar.setValue(processCount)
            i += 1

        self.MST.pop(0)
        print("Cost: ", total_cost)  # show total cost of our MST if needed
        self.dlg.progressBar.setValue(100)
        self.dlg.processbar_label.setText("Kruskal computed")
        QGuiApplication.processEvents()
        self.draw_MST_not()

    # this part is for add the center of polygon in our shp file.
    def add_point(self):
        self.dlg.processbar_label.setText("Adding Points")
        self.dlg.progressBar.setValue(0)
        self.all_points = []
        self.activelayer = self.getlayer.currentLayer()
        layer = self.activelayer
        epsg = layer.crs().postgisSrid()
        # determine the layer project and the type of data
        uri = "Point?crs=epsg:" + str(epsg) + "&field=id:integer""&index=yes"
        mem_layer = QgsVectorLayer(uri,
                                   'point',
                                   'memory')
        prov = mem_layer.dataProvider()
        i = 0
        for f in layer.getFeatures():
            self.all_points.append(i)
            feat = QgsFeature()
            # get the geometry and get the center of them as point (x,y)
            pt = f.geometry().centroid().asPoint()
            feat.setAttributes([i])  # we can add the features that we want to attribute table
            feat.setGeometry(QgsGeometry.fromPointXY(pt))  # the geometry that we will add to new row in shape file
            prov.addFeatures([feat])  # add one ore row to my shape file
            processCount = int((i / layer.featureCount()) * 100)
            self.dlg.progressBar.setValue(processCount)
            i += 1
        self.dlg.progressBar.setValue(100)
        self.dlg.processbar_label.setText("Points Added")
        QgsProject.instance().addMapLayer(mem_layer)  # we add the layer to my qgsi and show it
        QGuiApplication.processEvents()
        global bool_point
        bool_point = 1

    # draw MST by using kruskal
    def draw_MST_near(self):
        self.dlg.processbar_label.setText("Drawing MST")
        self.dlg.progressBar.setValue(0)
        # comment part is for add the prıject type of new added layer.
        epsg = self.activelayer.crs().postgisSrid()
        # new layer name and the data type of it data and where I would save it. so I save it on y ram
        uri = "LineString?crs=epsg:" + str(epsg) + "&field=id:integer""&index=yes"
        v_layer = QgsVectorLayer(uri, "MST_near", "memory")
        self.setUsingLayer('line')
        layer = self.activelayer
        pr = v_layer.dataProvider()  # make change on the new layers
        v_layer.startEditing()
        myField = QgsField("id", QVariant.Int, '', 0, 2)
        dp = v_layer.dataProvider()
        dp.addAttributes([myField])
        myField1 = QgsField("cost", QVariant.Int, '', 1, 2)
        dp = v_layer.dataProvider()
        dp.addAttributes([myField1])
        i = 0
        for edge in self.MST:
            for feature in layer.getFeatures():  # loop our features
                if feature[0] == edge[0]:  # to not take the same polygon
                    seg = QgsFeature()
                    seg.setGeometry(feature.geometry())
                    seg.setAttributes([feature.id(), feature.geometry().length()])
                    pr.addFeatures([seg])
                    v_layer.updateExtents()
                    v_layer.updateFeature(seg)
                    v_layer.commitChanges()
            processCount = int((i / len(self.MST)) * 100)
            self.dlg.progressBar.setValue(processCount)
            i += 1

        QgsProject.instance().addMapLayer(v_layer)
        self.dlg.progressBar.setValue(100)
        self.dlg.processbar_label.setText("Drawing MST Finished")
        QGuiApplication.processEvents()
        global bool_MST
        bool_MST = 1

    def draw_MST_not(self):
        self.dlg.processbar_label.setText("Drawing MST")
        self.dlg.progressBar.setValue(0)
        # comment part is for add the prıject type of new added layer.
        epsg = self.activelayer.crs().postgisSrid()
        # new layer name and the data type of it data and where I would save it. so I save it on y ram
        uri = "LineString?crs=epsg:" + str(epsg) + "&field=id:integer""&index=yes"
        v_layer = QgsVectorLayer(uri, "MST_not", "memory")
        self.setUsingLayer('line')
        layer = self.activelayer
        pr = v_layer.dataProvider()  # make change on the new layers
        v_layer.startEditing()
        myField = QgsField("id", QVariant.Int, '', 0, 2)
        dp = v_layer.dataProvider()
        dp.addAttributes([myField])
        myField1 = QgsField("cost", QVariant.Int, '', 1, 2)
        dp = v_layer.dataProvider()
        dp.addAttributes([myField1])
        i = 0
        for edge in self.MST:
            for feature in layer.getFeatures():  # loop our features
                if feature[0] == edge[0]:  # to not take the same polygon
                    seg = QgsFeature()
                    seg.setGeometry(feature.geometry())
                    seg.setAttributes([feature.id(), feature.geometry().length()])
                    pr.addFeatures([seg])
                    v_layer.updateExtents()
                    v_layer.updateFeature(seg)
                    v_layer.commitChanges()
            processCount = int((i / len(self.MST)) * 100)
            self.dlg.progressBar.setValue(processCount)
            i += 1

        QgsProject.instance().addMapLayer(v_layer)
        self.dlg.progressBar.setValue(100)
        self.dlg.processbar_label.setText("Drawing MST Finished")
        QGuiApplication.processEvents()
        global bool_MST
        bool_MST = 1

    # 加载矢量影像
    def loadVector(self):
        filenms, filetype = QFileDialog.getOpenFileNames(None, "打开矢量文件", None, "shape Files(*.shp)")
        for filenm in filenms:
            if filenm == '':
                pass
            else:
                filept = QFileInfo(filenm)
                self.basenm = filept.baseName()
                self.Vector_layer = QgsVectorLayer(filenm, self.basenm, "ogr")
                if not self.Vector_layer:
                    self.iface.messageBar().pushMessage("Error", "Layer loading failed", level=Qgis.Critical,
                                                        duration=3)
                    msg = QMessageBox()
                    msg.setText("加载失败")
                    msg.show()
                    print("加载失败!")
                else:
                    #mark2
                    QgsProject.instance().addMapLayer(self.Vector_layer)
                    self.layers.append(self.Vector_layer)
                    self.dlg.mapCanvas.setLayers(self.layers)
                    self.dlg.mapCanvas.setExtent(self.layers[len(self.layers)-1].extent())
                    self.dlg.mapCanvas.refresh()
                    # if self.dlg.Vector_textBrowser.toPlainText() != " ":

                    self.dlg.log_Browser.append("--------------------------------------")
                    self.dlg.log_Browser.append("---File " + self.basenm + "'s Info---")
                    self.dlg.log_Browser.append("Fileload Path:  " + filenm)
                    self.dlg.log_Browser.append("FileName:  " + self.basenm)
                    self.dlg.log_Browser.append("---query " + self.basenm + "'s Info---")
                    self.dlg.log_Browser.append("--------------------------------------")
                    self.dlg.log_Browser.append(" ")
                    self.iface.messageBar().pushMessage("Success", "Layer loading success",
                                                        level=Qgis.Success,
                                                        duration=3)
        self.layer = self.getlayer.currentLayer()
        global bool_point
        global bool_line
        global bool_MST
        bool_point = 0
        bool_line = 0
        bool_MST = 0

    # def minspan(self):
    #     # self.add_point()  # get all the centers of polygons
    #     # self.draw_line()  # draw lien between then neighbor polygon
    #     # self.kruskal()  # solve edges to find MST by using Kurskal
    #     # self.draw_MST()  # draw MST.
    #     global bool_point
    #     global bool_line
    #     global bool_MST
    #     #mark
    #     global radio
    #     # print(bool_point)
    #     # print(bool_line)
    #     # print(bool_MST)
    #     if self.dlg.comboBox.currentText() == "point" and bool_point == 0:
    #         self.add_point()
    #     if self.dlg.comboBox.currentText() == "line" and bool_line == 0 and bool_point == 0:
    #         self.add_point()
    #         self.draw_line()
    #     if self.dlg.comboBox.currentText() == "line" and bool_line == 0 and bool_point == 1:
    #         self.draw_line()
    #     if self.dlg.comboBox.currentText() == "MST" and bool_MST == 0 and bool_line == 0 and bool_point == 0:
    #         self.add_point()
    #         self.draw_line()
    #         self.kruskal()
    #     if self.dlg.comboBox.currentText() == "MST" and bool_MST == 0 and bool_line == 0 and bool_point == 1:
    #         self.draw_line()
    #         self.kruskal()
    #     if self.dlg.comboBox.currentText() == "MST" and bool_MST == 0 and bool_line == 1 and bool_point == 1:
    #         self.kruskal()

    # 分发span计算函数
    def minspan(self):
        global bool_point
        global bool_line
        global bool_MST
        global radio
        if self.dlg.comboBox.currentText() == "point" and bool_point == 0:
            self.add_point()
            self.dlg.log_Browser.append("--------------------------------------")
            self.dlg.log_Browser.append("---图层 " + self.getlayer.currentLayer().sourceName() + " 生成质心成功---")
            self.dlg.log_Browser.append("生成的质心图层名为 point")
            self.dlg.log_Browser.append("--------------------------------------")
            self.dlg.log_Browser.append(" ")
        if self.dlg.comboBox.currentText() == "line" and bool_line == 0 and bool_point == 0:
            if radio == 0:
                self.add_point()
                self.draw_line_near()
                self.dlg.log_Browser.append("--------------------------------------")
                self.dlg.log_Browser.append("---图层 " + self.getlayer.currentLayer().sourceName() + " 生成网格线成功---")
                self.dlg.log_Browser.append("生成方式为： 邻接")
                self.dlg.log_Browser.append("生成的质心图层名为 line_near")
                self.dlg.log_Browser.append("--------------------------------------")
                self.dlg.log_Browser.append(" ")
            elif radio == 1:
                self.add_point()
                self.draw_line_not()
                self.dlg.log_Browser.append("--------------------------------------")
                self.dlg.log_Browser.append("---图层 " + self.getlayer.currentLayer().sourceName() + " 生成网格线成功---")
                self.dlg.log_Browser.append("生成方式为： 非邻接")
                self.dlg.log_Browser.append("生成的质心图层名为 line_not")
                self.dlg.log_Browser.append("--------------------------------------")
                self.dlg.log_Browser.append(" ")
        if self.dlg.comboBox.currentText() == "line" and bool_line == 0 and bool_point == 1:
            if radio == 0:
                self.draw_line_near()
                self.dlg.log_Browser.append("--------------------------------------")
                self.dlg.log_Browser.append("---图层 " + self.getlayer.currentLayer().sourceName() + " 生成网格线成功---")
                self.dlg.log_Browser.append("生成方式为： 邻接")
                self.dlg.log_Browser.append("生成的质心图层名为 line_near")
                self.dlg.log_Browser.append("--------------------------------------")
                self.dlg.log_Browser.append(" ")
            elif radio == 1:
                self.draw_line_not()
                self.dlg.log_Browser.append("--------------------------------------")
                self.dlg.log_Browser.append("---图层 " + self.getlayer.currentLayer().sourceName() + " 生成网格线成功---")
                self.dlg.log_Browser.append("生成方式为： 非邻接")
                self.dlg.log_Browser.append("生成的质心图层名为 line_not")
                self.dlg.log_Browser.append("--------------------------------------")
                self.dlg.log_Browser.append(" ")
        if self.dlg.comboBox.currentText() == "MST" and bool_MST == 0 and bool_line == 0 and bool_point == 0:
            if radio == 0:
                self.add_point()
                self.draw_line_near()
                self.kruskal_near()
                self.dlg.log_Browser.append("--------------------------------------")
                self.dlg.log_Browser.append("---图层 " + self.getlayer.currentLayer().sourceName() + " 生成最小跨度线成功---")
                self.dlg.log_Browser.append("生成方式为： 邻接")
                self.dlg.log_Browser.append("生成的最小跨度线图层名为 MST_near")
                self.dlg.log_Browser.append("--------------------------------------")
                self.dlg.log_Browser.append(" ")
            elif radio == 1:
                self.add_point()
                self.draw_line_not()
                self.kruskal_not()
                self.dlg.log_Browser.append("--------------------------------------")
                self.dlg.log_Browser.append("---图层 " + self.getlayer.currentLayer().sourceName() + " 生成最小跨度线成功---")
                self.dlg.log_Browser.append("生成方式为： 非邻接")
                self.dlg.log_Browser.append("生成的最小跨度线图层名为 MST_not")
                self.dlg.log_Browser.append("--------------------------------------")
                self.dlg.log_Browser.append(" ")
        if self.dlg.comboBox.currentText() == "MST" and bool_MST == 0 and bool_line == 0 and bool_point == 1:
            if radio == 0:
                self.draw_line_near()
                self.kruskal_near()
                self.dlg.log_Browser.append("--------------------------------------")
                self.dlg.log_Browser.append("---图层 " + self.getlayer.currentLayer().sourceName() + " 生成最小跨度线成功---")
                self.dlg.log_Browser.append("生成方式为： 邻接")
                self.dlg.log_Browser.append("生成的最小跨度线图层名为 MST_near")
                self.dlg.log_Browser.append("--------------------------------------")
                self.dlg.log_Browser.append(" ")
            elif radio == 1:
                self.draw_line_not()
                self.kruskal_not()
                self.dlg.log_Browser.append("--------------------------------------")
                self.dlg.log_Browser.append("---图层 " + self.getlayer.currentLayer().sourceName() + " 生成最小跨度线成功---")
                self.dlg.log_Browser.append("生成方式为： 非邻接")
                self.dlg.log_Browser.append("生成的最小跨度线图层名为 MST_not")
                self.dlg.log_Browser.append("--------------------------------------")
                self.dlg.log_Browser.append(" ")
        if self.dlg.comboBox.currentText() == "MST" and bool_MST == 0 and bool_line == 1 and bool_point == 1:
            if radio == 0:
                self.kruskal_near()
                self.dlg.log_Browser.append("--------------------------------------")
                self.dlg.log_Browser.append("---图层 " + self.getlayer.currentLayer().sourceName() + " 生成最小跨度线成功---")
                self.dlg.log_Browser.append("生成方式为： 邻接")
                self.dlg.log_Browser.append("生成的最小跨度线图层名为 MST_near")
                self.dlg.log_Browser.append("--------------------------------------")
                self.dlg.log_Browser.append(" ")
            elif radio == 1:
                self.kruskal_not()
                self.dlg.log_Browser.append("--------------------------------------")
                self.dlg.log_Browser.append("---图层 " + self.getlayer.currentLayer().sourceName() + " 生成最小跨度线成功---")
                self.dlg.log_Browser.append("生成方式为： 非邻接")
                self.dlg.log_Browser.append("生成的最小跨度线图层名为 MST_not")
                self.dlg.log_Browser.append("--------------------------------------")
                self.dlg.log_Browser.append(" ")

    # 移除当前图层
    def Remove_maplayer(self):
        self.layer = self.getlayer.currentLayer()
        self.dlg.log_Browser.append("--------------------------------------")
        self.dlg.log_Browser.append("---图层 " + self.layer.sourceName() + " 删除成功---")
        self.dlg.log_Browser.append("--------------------------------------")
        self.dlg.log_Browser.append(" ")
        QgsProject.instance().removeMapLayer(self.layer)

    # def savelayer(self):
    #     self.dlg = InstantPrintTool(iface = self.iface)
    #     self.dlg.show()
    #     self.dlg.exec_()

    # 保存图层
    def Savelayer(self):
        options = QgsMapSettings()
        self.layer = self.getlayer.currentLayer()
        options.setLayers([self.layer])
        options.setBackgroundColor(QColor(255, 255, 255))
        options.setOutputSize(QSize(800, 600))
        options.setExtent(self.layer.extent())
        render = QgsMapRendererParallelJob(options)

        def save_image():
            img = render.renderedImage()
            self.filenm, self.filetype = QFileDialog.getSaveFileName(None, "文件保存", None, "jpg Files(*.jpg)")
            filept = QFileInfo(self.filenm)
            print(self.filetype, self.filenm, filept)
            img.save(self.filenm, "jpg")
            self.iface.messageBar().pushMessage("Save success", "layer save success",
                                                level=Qgis.Info,
                                                duration=3)

        render.finished.connect(save_image)
        render.start()
        self.dlg.log_Browser.append("--------------------------------------")
        self.dlg.log_Browser.append("图层 " + self.layer.sourceName() + "的保存信息开始记录---")
        # self.dlg.log_Browser.append("图层保存路径为： " + self.filenm)
        self.dlg.log_Browser.append("图层保存成功 ")
        self.dlg.log_Browser.append("图层 " + self.layer.sourceName() + "的保存信息记录结束---")
        self.dlg.log_Browser.append("--------------------------------------")
        self.dlg.log_Browser.append("")

    def btnstate(self, btn):
        # 输出按钮1与按钮2的状态，选中还是没选中
        global radio
        if btn.text() == '要求必须邻接':
            if btn.isChecked() == True:
                radio = 0

        if btn.text() == "不一定邻接":
            if btn.isChecked() == True:
                radio = 1
        #mark
        global bool_point
        global bool_line
        global bool_MST
        bool_point = 0
        bool_line = 0
        bool_MST = 0

    def is_near(self):
        global radio
        if radio == 0:
            pass
        # 邻接
        elif radio == 1:
            pass
        else:
            pass

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginVectorMenu(
                self.tr(u'&Network Tookit'),
                action)
            self.iface.removeToolBarIcon(action)

    def run(self):
        """Run method that performs all the real work"""
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        # if result:
        #     # Do something useful here - delete the line containing pass and
        #     # substitute with your code.
        #     if self.dlg.entryshpfile.text() != '' and self.inFiles == '':
        #         self.inFiles = self.dlg.entryshpfile.text()
        #         self.openShpFile()
        #     self.add_point()  # get all the centers of polygons
        #     self.draw_line()  # draw lien between then neighbor polygon
        #     self.kruskal()  # solve edges to find MST by using Kurskal
        #     self.draw_MST()  # draw MST.
